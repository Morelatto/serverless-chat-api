name: Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        options: [dev, staging, prod]
        default: dev

env:
  PYTHON_VERSION: '3.11'
  TERRAFORM_VERSION: '1.5.0'
  AWS_REGION: 'us-east-1'
  ECR_REPOSITORY: serverless-chat-api-dev

jobs:
  deploy:
    if: github.event_name == 'push' || github.event.inputs.environment == 'dev'
    runs-on: ubuntu-latest
    environment: dev
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip

      - name: Install and test
        env:
          CHAT_LLM_PROVIDER: gemini
          CHAT_GEMINI_API_KEY: test-api-key-for-ci
        run: |
          pip install -e ".[dev,test]"
          ruff check chat_api/ tests/
          pytest tests/ --cov=chat_api --cov-fail-under=70

      - name: Check AWS credentials
        id: check-aws
        run: |
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "has_aws=true" >> $GITHUB_OUTPUT
            echo "âœ… AWS credentials found"
          else
            echo "has_aws=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ AWS credentials not configured - skipping deployment"
          fi

      - uses: hashicorp/setup-terraform@v3
        if: steps.check-aws.outputs.has_aws == 'true'
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - uses: aws-actions/configure-aws-credentials@v4
        if: steps.check-aws.outputs.has_aws == 'true'
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        if: steps.check-aws.outputs.has_aws == 'true'
        working-directory: iac/terraform
        run: |
          # Use new state path to avoid conflicts with old state
          terraform init -reconfigure -backend-config="key=serverless/terraform.tfstate"

      - name: Clean up existing resources
        if: steps.check-aws.outputs.has_aws == 'true'
        continue-on-error: true
        run: |
          # Delete existing Lambda function and related resources
          aws lambda delete-function --function-name serverless-chat-api-dev 2>/dev/null || true
          aws logs delete-log-group --log-group-name /aws/lambda/serverless-chat-api-dev 2>/dev/null || true
          aws iam detach-role-policy --role-name serverless-chat-api-lambda-dev --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole 2>/dev/null || true
          aws iam delete-role-policy --role-name serverless-chat-api-lambda-dev --policy-name serverless-chat-api-lambda-policy 2>/dev/null || true
          aws iam delete-role --role-name serverless-chat-api-lambda-dev 2>/dev/null || true
          # Keep ECR repository as it has our images
          # Keep DynamoDB table to preserve data

      - name: Terraform Apply (Infrastructure Only)
        if: steps.check-aws.outputs.has_aws == 'true'
        working-directory: iac/terraform
        run: |
          # Determine LLM provider based on available keys
          if [ -n "${{ secrets.OPENROUTER_API_KEY }}" ]; then
            LLM_PROVIDER="openrouter"
          else
            LLM_PROVIDER="gemini"
          fi

          # First apply only ECR and supporting infrastructure (not Lambda)
          terraform apply -auto-approve \
            -target=aws_ecr_repository.lambda \
            -target=aws_iam_role.lambda \
            -target=aws_iam_role_policy_attachment.lambda_logs \
            -target=aws_iam_role_policy.lambda_dynamodb \
            -target=aws_dynamodb_table.main \
            -var="llm_provider=$LLM_PROVIDER" \
            -var="gemini_api_key=${{ secrets.GEMINI_API_KEY || 'dummy-key' }}" \
            -var="openrouter_api_key=${{ secrets.OPENROUTER_API_KEY || 'dummy-key' }}" \
            -var="api_key=${{ secrets.API_KEY || 'dev-key' }}"

      - name: Login to Amazon ECR
        if: steps.check-aws.outputs.has_aws == 'true'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        if: steps.check-aws.outputs.has_aws == 'true'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build --build-arg TARGET=lambda -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Terraform Apply (Lambda Function)
        if: steps.check-aws.outputs.has_aws == 'true'
        working-directory: iac/terraform
        run: |
          # Determine LLM provider based on available keys
          if [ -n "${{ secrets.OPENROUTER_API_KEY }}" ]; then
            LLM_PROVIDER="openrouter"
          else
            LLM_PROVIDER="gemini"
          fi

          # Now apply Lambda function and URL
          terraform apply -auto-approve \
            -var="llm_provider=$LLM_PROVIDER" \
            -var="gemini_api_key=${{ secrets.GEMINI_API_KEY || 'dummy-key' }}" \
            -var="openrouter_api_key=${{ secrets.OPENROUTER_API_KEY || 'dummy-key' }}" \
            -var="api_key=${{ secrets.API_KEY || 'dev-key' }}"

      - name: Update Lambda function
        if: steps.check-aws.outputs.has_aws == 'true'
        run: |
          aws lambda update-function-code \
            --function-name serverless-chat-api-dev \
            --image-uri ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest \
            --region ${{ env.AWS_REGION }}

          # Wait for update to complete
          aws lambda wait function-updated \
            --function-name serverless-chat-api-dev \
            --region ${{ env.AWS_REGION }}

      - name: Get Lambda URL
        if: steps.check-aws.outputs.has_aws == 'true'
        id: get-url
        run: |
          FUNCTION_URL=$(aws lambda get-function-url-config \
            --function-name serverless-chat-api-dev \
            --query 'FunctionUrl' \
            --output text 2>/dev/null || echo '')
          echo "function_url=$FUNCTION_URL" >> $GITHUB_OUTPUT
          if [ -n "$FUNCTION_URL" ]; then
            echo "ðŸš€ Lambda deployed at: $FUNCTION_URL"
          fi

      - name: Test deployment
        if: steps.check-aws.outputs.has_aws == 'true' && steps.get-url.outputs.function_url != ''
        run: |
          sleep 10
          echo "Testing Lambda at: ${{ steps.get-url.outputs.function_url }}"
          curl -f "${{ steps.get-url.outputs.function_url }}health" || echo "Health check failed but continuing"

  deploy-staging:
    if: github.event.inputs.environment == 'staging'
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v4
      - run: echo "Staging deployment not configured yet"

  deploy-prod:
    if: github.event.inputs.environment == 'prod'
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - uses: actions/checkout@v4
      - run: echo "Production deployment not configured yet"
